---
title: "heart_transplant_exceptions"
author: "Daniel Johnson"
date: "06/20/2022"
output:
  pdf_document:
    toc: yes
    toc_depth: '2'
  html_notebook:
    theme: journal
    toc: yes
    toc_depth: 2
    toc_float: yes
---
# Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

# Loading in packages

This chunk is used to load in the packages in R that help us to tidy, manipulate, and visualize the data.

```{r library}
library(tidyverse) 
library(ggplot2) 
library(haven)
library(coxme)
library(survminer)
library(rmdformats)
```
# Data sources

## Cleaned Standard Scientific Registry of Transplant Recipients (SRTR) SAF files

```{r data_in}
#cand_thor <- read_sas("C:/Users/Daniel/Box/SRTR Data 2021 Q4/SAF (pubsaf2112)/cand_thor.sas7bdat") 
#stathist_thor <- read_sas("C:/Users/Daniel/Box/SRTR Data 2021 Q4/SAF (pubsaf2112)/stathist_thor.sas7bdat") 

load("C:/Users/Daniel/Box/Heart Data Pipeline/New .RData files/full_list_final_2022-06-13.RData")
```

# Survival Analysis ------------------------------------------------------------

# You want to do survival analysis and thus need variables that indicate pre-transplant death as well as reasons for removal from the waitlist.

#Here I created a new variable called DEATH_DT, which basically combines both the OPTN and SSA death dates.
cand_thor <- cand_thor %>%
  mutate(
    DEATH_DT = case_when(
      !is.na(PERS_OPTN_DEATH_DT) ~ PERS_OPTN_DEATH_DT,
      is.na(PERS_OPTN_DEATH_DT) ~ PERS_SSA_DEATH_DT
    )
  )

#Several patients may be removed from the waitlist without getting a transplant but still die. This variable DEATH accounts for that. Basically,
#if a patient has a removal code for anything other than transplantation and has a DEATH_DT on file, then they are coded as having died.
cand_thor$DEATH <- ifelse(
  cand_thor$CAN_REM_CD == 8 |
    (cand_thor$CAN_REM_CD == 5 & !is.na(cand_thor$DEATH_DT)) |
    (cand_thor$CAN_REM_CD == 6 & !is.na(cand_thor$DEATH_DT)) |
    (cand_thor$CAN_REM_CD == 7 & !is.na(cand_thor$DEATH_DT)) |
    (cand_thor$CAN_REM_CD == 9 & !is.na(cand_thor$DEATH_DT)) |
    (cand_thor$CAN_REM_CD == 10 & !is.na(cand_thor$DEATH_DT)) |
    (cand_thor$CAN_REM_CD == 11 & !is.na(cand_thor$DEATH_DT)) |
    (cand_thor$CAN_REM_CD == 12 & !is.na(cand_thor$DEATH_DT)) |
    (cand_thor$CAN_REM_CD == 13 & !is.na(cand_thor$DEATH_DT)) |
    (cand_thor$CAN_REM_CD == 16 & !is.na(cand_thor$DEATH_DT)) |
    (cand_thor$CAN_REM_CD == 17 & !is.na(cand_thor$DEATH_DT)) |
    (cand_thor$CAN_REM_CD == 20 & !is.na(cand_thor$DEATH_DT)) |
    (cand_thor$CAN_REM_CD == 24 & !is.na(cand_thor$DEATH_DT)), 1, 0)

cand_thor <- cand_thor %>% mutate(DEATH = ifelse(is.na(DEATH), 0, DEATH))

#Same here, but I wanted to create a new variable for the removal date. If they died, make the removal date the death date. If they haven't
#died, make the removal date their removal date.
cand_thor <- cand_thor %>% mutate(
  REMOVAL_DATE = ifelse(
    (cand_thor$CAN_REM_CD == 5 & !is.na(cand_thor$DEATH_DT)) |
      (cand_thor$CAN_REM_CD == 6 & !is.na(cand_thor$DEATH_DT)) |
      (cand_thor$CAN_REM_CD == 7 & !is.na(cand_thor$DEATH_DT)) |
      (cand_thor$CAN_REM_CD == 9 & !is.na(cand_thor$DEATH_DT)) |
      (cand_thor$CAN_REM_CD == 10 & !is.na(cand_thor$DEATH_DT)) |
      (cand_thor$CAN_REM_CD == 12 & !is.na(cand_thor$DEATH_DT)) |
      (cand_thor$CAN_REM_CD == 13 & !is.na(cand_thor$DEATH_DT)) |
      (cand_thor$CAN_REM_CD == 16 & !is.na(cand_thor$DEATH_DT)) |
      (cand_thor$CAN_REM_CD == 17 & !is.na(cand_thor$DEATH_DT)) |
      (cand_thor$CAN_REM_CD == 20 & !is.na(cand_thor$DEATH_DT)) |
      (cand_thor$CAN_REM_CD == 24 & !is.na(cand_thor$DEATH_DT)), DEATH_DT, CAN_REM_DT))

#R codes dates as days after January 1, 1970, so I just specified that to make sure all dates I am working with are standardized.
cand_thor$REMOVAL_DATE <- as.Date(cand_thor$REMOVAL_DATE, origin = "1970-01-01")
cand_thor$REC_TX_DT <- as.Date(cand_thor$REC_TX_DT, origin = "1970-01-01")

#LASTDATE is basically your date of death set up for survival analysis. If your patient died, then the last date is REMOVAL_DATE. If your 
#patient did not die, then the last date will be the date that they were last active on the list (CAN_LAST_ACT_STAT_DT).
cand_thor <- cand_thor %>%
  mutate(
    LASTDATE = case_when(
      is.na(REMOVAL_DATE) ~ CAN_LAST_ACT_STAT_DT,
      TRUE ~ REMOVAL_DATE
    )
  )

#If a patient is not removed from the waitlist yet, then they are coded as 0. Death = 1. Transplant = 2. All other causes = 3.
cand_thor <- cand_thor %>%
  mutate(
    REMOVAL_CAUSE = case_when(
      is.na(CAN_REM_CD) ~ 0,
      DEATH == 1 ~ 1,
      CAN_REM_CD == 4 ~ 2,
      TRUE ~ 3
    )
  )

cand_thor <- cand_thor %>%
  mutate(
    removaltype = case_when(
      REMOVAL_CAUSE == 0 | REMOVAL_CAUSE == 3 ~ 0,
      REMOVAL_CAUSE == 1 ~ 1,
      REMOVAL_CAUSE == 2 ~ 2
    )
  )

#for my competing risks analysis, I want to censor patients who were not removed from the waitlist or were removed but not for death or transplantation. 
cand_thor <- cand_thor %>%
  mutate(
    CENSOR_DT = case_when(
      REMOVAL_CAUSE == 0 ~ CAN_LAST_ACT_STAT_DT,
      REMOVAL_CAUSE == 3 ~ CAN_REM_DT
    ))

cand_thor <- cand_thor %>%
  mutate(
    FINAL_REMOVAL_DATE = case_when(
      removaltype == 0 ~ CENSOR_DT,
      removaltype == 1 ~ DEATH_DT,
      removaltype == 2 ~ REC_TX_DT
    )
  )

#Code for the number of days from your listing date to your removal date. Use TIME_TO_REMOVAL for cumulative incidence and competing risks regression analysis.
cand_thor <- cand_thor %>%
  mutate(TIME_TO_REMOVAL = as.numeric(difftime(FINAL_REMOVAL_DATE, CAN_LISTING_DT, units = "days")))

cand_thor <- cand_thor %>%
  mutate(TIME_TO_REMOVAL_YEARS = TIME_TO_REMOVAL / 365.25)

#Code for pre-transplant survival time. Use SURVIVAL_TIME for Kaplan-Meier analysis.
cand_thor <- cand_thor %>%
  mutate(SURVIVAL_TIME = as.numeric(difftime(LASTDATE, CAN_LISTING_DT, units = "days")))

cand_thor <- cand_thor %>%
  mutate(SURVIVAL_TIME_YEARS = SURVIVAL_TIME / 365.25)

#EXAMPLE
survplot1 <-
  ggsurvplot(
    fit = survfit(Surv(SURVIVAL_TIME, DEATH), data = cand_thor),
    pval = TRUE, 
    conf.int = FALSE,
    risk.table = TRUE, 
    risk.table.col = "strata",
    xlim = c(0, 180),
    xlab = "Time after Listing in Days",
    break.time.by = 45,
    ylab = "Survival Probability",
    censor = TRUE,
    risk.table.y.text.col = T, 
    risk.table.y.text = FALSE
  ) 

# Cox model --------------------------------------------------------------------
#placeholder for dataset of patients you are interested in
cand_thor_short <- cand_thor %>% filter(WL_ORG == "HR" & CAN_LISTING_DT >= as.POSIXct("2016-06-01")) %>% 
  dplyr::select(c("PX_ID", "CAN_REM_DT", "CAN_REM_CD", "CAN_GENDER", "CAN_RACE"))

#i merged the patient file with stathist_thor, which has all status updates occurring during the waitlist. i then
#grouped by patient ID and arranged individual rows in chronological order of their "CANHX_BEGIN_DT." then I created
#two columns, Time1 and Time2, as the number of days after a patient was placed on the waitlist. If the last CANHX_END_DT was 
#empty, I put in the last date updated by the overall system, which is 12/31/2021 for the 2021 Q4 update.
hearts <- merge(cand_thor_short, stathist_thor, by = "PX_ID", all.x = TRUE) %>% group_by(PX_ID) %>% 
  arrange(CANHX_BEGIN_DT) %>% mutate(TIME1 = as.numeric(difftime(CANHX_BEGIN_DT, CAN_LISTING_DT, units = "days")),
                                     TIME2 = as.numeric(difftime(CANHX_END_DT, CAN_LISTING_DT, units = "days")) + 1,
                                     TIME2 = case_when(
                                       is.na(TIME2) ~ as.numeric(difftime("2021-12-31", CAN_LISTING_DT, units = "days")),
                                       TRUE ~ TIME2))

mixedmodel <- coxme(Surv(TIME1, TIME2, DEATH) ~ Var1 + Var2 + ... + VarX, data = hearts)

# Vars from Topkara: Age at listing, sex, race (white vs. non-white), ischemic cause of heart failure, blood type,
# body surface area, poor functional status (binary), UNOS status at listing, status exception, UNOS region, inotrope at 
# listing, IABP at listing, ECMO at listing, MCSD at listing, heart-kidney listing, serum creatinine

# Vars from Daniel: NEW_SCORE, exception, race, sex, agegroup, candidate listing center ID (1 | CAN_LISTING_CTR_ID)
mixedmodel_d <- coxme(Surv(TIME1, TIME2, DEATH) ~ CAN_LAST_STAT + EXCEPTION + CAN_RACE + CAN_AGE_AT_LISTING + CAN_GENDER + (1 | CAN_LISTING_CTR_ID), data = hearts)
